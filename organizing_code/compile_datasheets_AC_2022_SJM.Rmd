---
title: "Compile Flower, Fruit, and Seed count data sheets_AC_2023"
output: html_notebook
author: Devin Gamble (with additional annotations & code by Susan Mazer)
editor_options: 
  chunk_output_type: inline
---


```{r message = FALSE, warning = FALSE}
#Load Packages
library(tidyverse)
library(janitor)
library(here)
library(lubridate)
library(reshape2)
library(stringr)

```



## Load and Clean Data   

NOTE: All date data should be standardized prior to importing into R. In Excel, set format to YYYY-MM-DD for consistency.  In Excel, select Date menu --> More Number Options -->   YYYY-MM-DD.  Do this for all columns with a date. SAVE.  When you open up the Excel file again, it won't display the YYYY-MM-DD format, but R will read it as such, and the variable should appear as a character variable.  (e.g., "2022-12-05")

NOTE 2: All paths are relative using the 'here' package.  


**Germination Data**  
- Add 'Date Sown' column and data in as well.
- for AC germination, plant number must be FLIPPED (i.e., plants 1,2,3,4,5,6,7,8,9,10 become plants 10,9,8,7,6,5,4,3,2,1, respectively) 
```{r message = FALSE}
#Load csv

#Skip first nonsense row (the second row is the header)
AC_germ_df1 <- read_csv(here::here("data_sheets", "germination_checks_2021-2022", "AC_germ_data.csv"), skip = 1) %>%
  rename(Block = 'Block (1-3)', Transect = 'Transect (1-9)', Sequence = 'Sequence (1-321)', Donor = "Pollen Donor ID", Recipient = "Maternal Sibship", Stage = 'mm/dd') %>% 
  filter(!Stage == "Flow Date")   #Remove empty flowering date rows

#View(AC_germ_df1)
#Reshape data sheet to 'long' format
AC_germ_df2 <- AC_germ_df1 %>% 
  pivot_longer(cols = c('1':'10'),
               names_to = 'Plant_ID',
               values_to = 'Germ_Date') 

#View(AC_germ_df2)
##Fix typos in date values
##Excel auto-populated year as 2022 when in fact the year in which germination occurred should be 2021!
unique(AC_germ_df2$Germ_Date)

AC_germ_df3 <- AC_germ_df2 %>% 
  mutate(Germ_Date = replace(Germ_Date, Germ_Date %in% c("Dead 12/5, plug missing", "disturbed by animal (deer)", "? disturbed by animal (deer)"), NA)) %>% 
  
# The code above specifies those values in the Germ_Date column to assign 'NA'.  These are values that will not be used to calculate the probability of germination.
  
# In other words, keep the variable named Germ_Date, but in the current Germ_Date column, replace any values in that are a member of the c() vector with the value "NA".
  
# The code below will inspect all remaining values in the Germ_Date column and replace the following values with "2021-12-05": "2022-12-05", "12/5, ? plug buried", "12/5/2021, ?", "12/5/2021, disturbed by animal (deer)"
  
# The code below will then inspect all remaining values in the Germ_Date column and replace the following values with "2021-11-03": "2022-11-03", "11/3/2021, disturbed by animal (deer)", "11/3 (n=2, n=1 on 12/5)"
  
mutate(
  Germ_Date = case_when(
    Germ_Date %in% c("2022-12-05", "12/5, ? plug buried", "12/5/2021, ?", "12/5/2021, disturbed by animal (deer)") ~ "2021-12-05",
    Germ_Date %in% c("2022-11-03", "11/3/2021, disturbed by animal (deer)", "11/3 (n=2, n=1 on 12/5)") ~ "2021-11-03")) 

#check again
unique(AC_germ_df3$Germ_Date)
#Use sum(is.na(AC_germ_df2$Germ_Date)) to compare change in number of NA values

sum(is.na(AC_germ_df1)) #452 values are "NA" in AC_germ_df2

sum(is.na(AC_germ_df2$Germ_Date)) #452 values are "NA" in AC_germ_df2

sum(is.na(AC_germ_df3$Germ_Date)) #456 values are "NA" in AC_germ_df2

#
#Adjust Donor and Recipient names for easy sorting - three digits (leading zeros)
#Specify Germ_Date as 'date' class variable

# sprintf is used to print formatted strings

# parse_number parses the first number it finds, dropping any non-numeric characters before the first number and all characters after the first number. So, for example, Recipient AC_200 would appear as "200" because the "AC_" would be dropped.  The %03d means that the format of the number of the recipient must appear as 3 digits, with one or two leading 0's as needed to provide 3 digits. 

AC_germ_df4 <- AC_germ_df3 %>% 
  mutate(Recipient_num = sprintf("%03d", (parse_number(Recipient)))) %>% # Creates new variable, "Recipient_num". parse_number() function strips off all letters or symbols of a character variable's "value" until the first number is reached.  %03d adds leading 0s to ensure that each number is represented by 3 digits.  So, "Recipient_num" contains the 3-digit version of a Recipient's ID number.
  mutate(Recipient = as.character(str_c("AC_", Recipient_num))) %>% # Replaces current "Recipient" column with a new one.
  mutate(Donor_num = sprintf("%03d", (parse_number(Donor)))) %>% 
  mutate(Donor = as.character(str_c("AC_", Donor_num))) %>%
  mutate(Germ_Date = as_date(Germ_Date)) %>% #set variable to class = date
  select(Block, Transect, Sequence, Donor, Donor_num, Recipient, Recipient_num, Plant_ID, everything()) %>% 
  select(-c(Stage, Donor_num, Recipient_num))

#
##Add in Sow Date (lab sown) and Plant date (in field)
AC_germ_df5 <- AC_germ_df4 %>% 
  mutate(Sow_Date = as_date("2021-10-27")) %>% 
  mutate(Plant_Date = as_date("2021-11-04"))
#Some plugs may have been sown on November 5, 2022 (information on which transects not recorded)


#
## Flip Plant numbers
## (AC germination data only) - the orientation in which plants were identified and checked for flowering was reversed
AC_germ_df6 <- AC_germ_df5 %>% 
  mutate(Plant_ID = as.numeric(case_when(
    Plant_ID == "1" ~ "10",
    Plant_ID == "2" ~ "9",
    Plant_ID == "3" ~ "8",
    Plant_ID == "4" ~ "7",
    Plant_ID == "5" ~ "6",
    Plant_ID == "6" ~ "5",
    Plant_ID == "7" ~ "4",
    Plant_ID == "8" ~ "3",
    Plant_ID == "9" ~ "2",
    Plant_ID == "10" ~ "1"))) %>% 
  arrange(Block, Transect, Sequence, Recipient, Plant_ID)  #Arrange by Transect, Recipient, Plant_ID
  

```


# Add in watered transect germination data

```{r message = FALSE}
#AC
## Add in watered transects
## *Note*: Only 8 seeds sown in these segments instead of 10
AC_germ_W1 <- read_csv(here::here("data_sheets", "germination_checks_2021-2022", "watered_AC_germ.csv"), skip = 1) %>%
  rename(Sequence = 'Seq (1-42)', Donor = "Donor_ID", Recipient = "Recipient_ID", Stage = "Date (mm/dd)") %>% 
  filter(!Stage == "Flow") %>%    #Remove empty flowering date rows
  mutate(`2` = as_date(`2`), `5` = as_date(`5`), `8` = as_date(`8`)) #these columns not recognized as dates during read-in. These must all be the same class since they'll be reshaped below.
  
#
#Reshape data sheet to 'long' format
AC_germ_W2 <- AC_germ_W1 %>% 
  pivot_longer(cols = c('1':'8'),
               names_to = 'Plant_ID',
               values_to = 'Germ_Date') 

#View(AC_germ_W2)
#
##Fix typos in date values
unique(AC_germ_W2$Germ_Date) #no typos here

# Change sowing/germination year from 2022 to 2021

AC_germ_W3 <- AC_germ_W2 %>% 
  mutate(Germ_Date = case_when(
    Germ_Date == "2022-12-05" ~ "2021-12-05",
    Germ_Date == "2022-11-03" ~ "2021-11-03"))


#
#Adjust Donor and Recipient names for easy sorting - three digits (leading zeros)
#Specify Germ_Date as 'date' class variable.

AC_germ_W4 <- AC_germ_W3 %>% 
  mutate(Recipient_num = sprintf("%03d", (parse_number(Recipient)))) %>% 
  mutate(Recipient = as.character(str_c("AC_", Recipient_num))) %>% 
  mutate(Donor_num = sprintf("%03d", (parse_number(Donor)))) %>% 
  mutate(Donor = as.character(str_c("AC_", Donor_num))) %>%
  mutate(Germ_Date = as_date(Germ_Date)) %>% #set variable to class = date
  mutate(Plant_ID = as.numeric(Plant_ID)) %>% #set Plant ID to numeric for sorting purposes
  select(-c(Stage, Co., Donor_num, Recipient_num))


#
##Add in Sow Date & Update Sequence number & add block ('W')
AC_germ_W5 <- AC_germ_W4 %>% 
  mutate(Sow_Date = as_date("2021-10-27")) %>% 
  mutate(Plant_Date = as_date("2021-11-04")) %>% 
  mutate(Sequence = (Sequence + 321)) %>% # Each number in the sequence is the number of a one-meter segment
  mutate(Block = "W") %>% 
  select(Block, Transect, Sequence, Donor, Recipient, Plant_ID, everything()) %>% 
  arrange(Transect, Sequence, Recipient, Plant_ID) #Arrange by Transect, Recipient, Plant_ID
## Flipping Plant numbers not required for watering transects - plugs planted top-to-bottom for ID 1 through 8

# Make sure that unwatered and watered transects have the same variable names so that we can proceed with rbind

names(AC_germ_df6)
names(AC_germ_W5)
#
## Combine watered and main experiment germination data
AC_germ_full <- rbind(AC_germ_df6, AC_germ_W5)

#write_csv(AC_germ_full, here::here("data_sheets", "compiled_sheets", "AC_germination_full_2021-2022.csv"))

```


**Flower Check sheets**  
-- Organize flowering data

*Important Step!!*  
In the csv file, select all data with dates (visit dates, leaf sampling, and flower photos). Right click --> format cells. Select the date category --> YYYY-MM-DD. Save the csv and close it. This will standardize all dates to the same format and make working with them in R much easier!  


```{r}
ACflr_df <- read_csv(file = here::here( "data_sheets", "season_end_flowerchecks_2022",  "AC_flowercheck_2022_06_28.csv"), na = c("", "NA"))

sum(is.na(ACflr_df)) #34029

##Ignore 'F' plants - more up-to-date fitness plant data is matched in below 

# The variable names include column numbers (not sure why) and flowering dates, which are filled in where a given Plant_ID was observed in flower.  Plant_IDs 1-5 are in column 3, and Plant_IDs 6-10 are in column 17

# So, there are two groups of flowering date observations:  Columns 1-15 and columns 16-29, with columns 15 and 29 containing the date on which a flower photo was taken.

View(ACflr_df)
#Re-structure data: split data into data for plants 1-5 and data for plants 6-10

f1_AClong <- ACflr_df[c(1:15)] # Group 1: plants 1-5
f2_AClong <- ACflr_df[c(1, 16:29)] # Group 2: plants 6-10, along with transect number (column 1)

#Revise names:  Note that no Plant_IDs from 1-5 were reported to flower on 6.22, and there are 2 subsequent empty columns (after the 6.22 column) that will be named "D" and "D1".  A few Plant_IDs from 6-10 were flowering on 6.22, and this date is also followed by 2 empty columns that will similarly be named "D" and "D1".

# The fitness plant column and D and D1 will be removed after joining the two data frames

colnames(f1_AClong) <- c("Transect", "Recipient", "Plant_ID", "F.", "Fl_4.9", "Fl_4.21", "Fl_5.3", "Fl_5.13", "Fl_5.25", "Fl_6.8", "Fl_6.22", "D", "D1", "LEAF", "flr_P")
colnames(f2_AClong) <- c("Transect", "Recipient", "Plant_ID", "F.", "Fl_4.9", "Fl_4.21", "Fl_5.3", "Fl_5.13", "Fl_5.25", "Fl_6.8", "Fl_6.22", "D", "D1", "LEAF", "flr_P")

#rbind, tidy up and remove unnecessary columns and empty rows

f_AClong <- rbind(f1_AClong, f2_AClong) %>% arrange(Transect, Recipient, Plant_ID) %>% select(-c(F., D, D1)) %>% remove_empty("rows") #sort by transect, then Recipient, then Plant ID

# before remove_empty, f_AClong has 3552 obs
# after remove_empty, f_AClong has 3546 obs

#Format recipient IDs for easier sorting - three digits (includes leading zeros)
f_AClong_2 <- f_AClong %>% 
  mutate(Recipient_num = sprintf("%03d", (parse_number(Recipient)))) %>% 
  mutate(Recipient = as.character(str_c("AC_", Recipient_num))) %>% 
  select(Transect, Recipient, Recipient_num, Plant_ID, everything()) %>% 
  select(-Recipient_num)

#View(f_AClong_2)
##Fix Dates:  there are a few instances in which, for example, for plants first observed to flower on 2022-04-21, the date was incorrectly entered in the column for 4.9 (2022-04-09)

# So, the code below, in the column called "Fl_4.21", plants observed to be in flower on 2022-04-21 are recorded as 2022-04-21 and plants observed to be in flower on 2022-04-22 are recorded as 2022-04-22, even when 2022-04-22 was erroneously placed in the Fl_4.9 column.  

# Similarly, in the column "Fl_4.9", plants observed to be in flower on 2022-04-09 are recorded as "2022-04-09".

# Finally, in the column "Fl_6.22", plants observed to be in flower on 2022-06-22 are recorded as "2022-06-22".  One plant, oddly recorded as "19165" on that day is now recorded as "2022-06-22".


f_AClong_3 <- f_AClong_2 %>% 
  mutate(Fl_4.21 = case_when(Fl_4.9 == "2022-04-22" ~ "2022-04-22",
                             Fl_4.21 == "2022-04-22" ~ "2022-04-22",
                             Fl_4.21 == "2022-04-21" ~ "2022-04-22")) %>% 
  mutate(Fl_4.9 = case_when(Fl_4.9 == "2022-04-09" ~ "2022-04-09",
                            TRUE ~ as.character(NA))) %>%  # "TRUE" ~ means "if none of the previous conditions are met, then assign value as follows: (in this case, as a character variable with the value "NA")
  mutate(Fl_6.22 = case_when(Fl_6.22 == 19165 ~ "2022-06-22",
                             TRUE ~ as.character(NA)))

unique(f_AClong_3$Fl_4.9)

tail(f_AClong_3) # Includes both watered and unwatered transects (n=3546 seeds/plants)

# In code above, the TRUE ~ as.character(NA) means that any cell entries that do not fulfill the previously listed conditions will be turned into NA as a character variable (like the dates). This is needed because all variables on the right hand side (RHS) of the case_when function must be of the same class (character, in this case). Below, we will change the character variables to dates using as_date()

```


Combine Germination and Flowering data frames
```{r}
#Merge by Recipient, Transect, and Plant ID

#AC_germ_full includes both unwatered and watered transects (n=3546 seeds/plants)

# f_AClong_3 also includes 3546 seeds/plants.  So the two data frames have the same number of rows.  Joining them by Recipient, Transect, and Plant_ID will yield one dataframe with planting date, germination date, and the dates on which each Plant_ID in each Transect was observed in flower.

AC_GermFlow_1 <- left_join(AC_germ_full, f_AClong_3, by = c("Recipient", "Transect", "Plant_ID")) %>% 
  mutate(Fl_6.22 = as_date(Fl_6.22),
         Fl_4.9 = as_date(Fl_4.9),
         Fl_4.21 = as_date(Fl_4.21)) #correct these columns to be class 'date'

head(AC_GermFlow_1)
#Double-check that observation (row) numbers match up. Note that watered Transects only have 8 Plant_IDs per segment.

#View(AC_GermFlow_1)

unique(AC_GermFlow_1$LEAF) # Leaves collected on four dates

```

<br>  


#### Fitness Plant data  
- Indicate which plants were fitness plants, including those replicated in the watering experiment

```{r message = FALSE}

AC_Fplants <- read_csv(here::here("data_sheets", "fitness_plants_7-21-2022", "AC_F_plants.csv") , col_types = cols(`ALL Fitness Plants` = col_character())) %>% #retain commas between Plant_ID values in the cells of the column with multiple fitness plants.  Column named "ALL Fitness Plants" is read in as a character variable so that commas are retained
  rename(F_plant = `SINGLE Fitness Plant`, F_multi = `ALL Fitness Plants`, F_plant_notes = NOTES) %>% 
  select(Transect:F_plant_notes)

# AC_Fplants contains two columns, one with the Plant_ID of the selected fitness plant, and the other with the Plant_IDs of both the selected fitness plant and the replicates (if there are back-up fitness plants)

AC_Fplants %>% count(Replicated) # n=103

tail(AC_Fplants)
# There are 363 Fitness Plants in 2022 for AC

#Adjust Recipient names to match three-digit format
AC_Fplants2 <- AC_Fplants %>% 
  mutate(Recipient_num = sprintf("%03d", (parse_number(Recipient)))) %>% 
  mutate(Recipient = as.character(str_c("AC_", Recipient_num))) %>% 
  select(-Recipient_num) %>% #exclude the Recipient_num column
  mutate(Replicated = case_when(Replicated == "R" ~ "R",
                                is.na(Replicated) ~ "n")) #change NAs to 'n' (no) for non-rep'd Recipient IDs

tail(AC_Fplants2)

```


Index fitness plants & Replicated (y/n) in germination and flowering data

The case_when function takes one or more logical conditions and, if they are met, assigns the outcome to a logical variable assigned to either TRUE or FALSE.  If conditions that lead to both TRUE and FALSE assignments are not fully specified, then the function must include a final line that means "if none of the above conditions are met", then set value to TRUE (or FALSE)."  In the example below, the "TRUE ~ FALSE" statement achieves this.

Example:

mutate(FitP = case_when(F_plant == Plant_ID ~ TRUE,
          TRUE ~ FALSE))
          
Here, a logical variable called FitP is created that = TRUE when F_plant == Plant_ID; otherwise, FitP = FALSE.

```{r message = FALSE}
# Merge the two dataframes - F plant data will be repeated x10 

# Create new row (Plant ID) specific variables for main and replicated fitness plants

  # IMPORTANT:  All rows within a given one-meter segment include all of the Fitness Plant replicates in the "F_Multi" column of AC_Fplants2.

AC_GermFlow_2 <- merge(AC_GermFlow_1, AC_Fplants2) %>% 
  mutate(FitP = case_when(F_plant == Plant_ID ~ TRUE, 
                           F_plant != Plant_ID ~ FALSE)) %>% # Creates a logical variable called FitP, the value of which is "TRUE" for all rows represented by the selected Fitness Plant.  For example, when the Plant_ID and the F_plant column are identical, then FitP = "TRUE".  When Plant_ID and F_plant are not the same, then the value of FitP = FALSE. This classification of FitP will make it easy in the future to filter this data frame to choose only the Main Fitness plants.

    # After creating FitP, we want to create two more columns.  The first (Rep_FitP) will = TRUE when the Plant_ID is one of two or more replicates available (including the main fitness plant). If the Main Fitness plant is the ONLY plant measured in a segment, then "Rep_FitP" = FALSE for the Main Fitness plant.  If the Main Fitness plant is one of TWO or MORE replicate plants measured in a segment, then "Rep_FitP" = TRUE for the Main Fitness plant AND for the replicate plants. 
  
  # The second column (Any_FitP) is assigned to TRUE if either FitP or Rep_FitP are TRUE. It will be FALSE, however, if a Plant_ID is used to measure a given trait but is neither the Main Fitness Plant or a plant chosen as a Replicate.
  
  # APPROACH:  To Assign the value of "Rep_FitP", must first find character strings that are the same in Plant_ID and Multi_F columns.  If the Plant_ID is the fitness plant and ALSO listed in Multi_F (Replicated == "R"), then its value for Rep_FitP = TRUE; if the Plant_ID is the Main Fitness plant and there are no replicates (Replicated = "n"), then its Rep_FitP = FALSE.
  
  # Steps:  (1) Convert a row's Plant_ID to a character string; (2) search for this character string, which will be a number from 1-10, in Multi_F; (3) if a match is found, re-convert it back to numeric; and (4) use it in the "Plant_ID == " to generate the logical output of TRUE or FALSE.  If the Plant ID is found in the Multi_F column, AND if there are replicates in the segment, then Rep_FitP = TRUE.
  
  
  mutate(Rep_FitP = case_when(Replicated == "R" & Plant_ID != 1 & Plant_ID == as.numeric(str_match(F_multi, as.character(Plant_ID))) ~ TRUE, # By excluding Plant_IDs=1, this code will prevent str_match from matching '1' to the 1 in '10'.  The "Plant_ID == as.numeric..." condition will return TRUE when Plant_IDs = 2, 3, 4, 5, 6, 7, 8, 9, or 10 appear in F_multi
                              
                              Replicated == "R" & Plant_ID == 1 & Plant_ID == as.numeric(str_match(F_multi, "1(?!0)")) ~ TRUE, # The "Plant_ID == as.numeric..." condition will return TRUE when Plant_ID = 1 appears in F_multi. Here, the match is required to be a 1, NOT followed by a 0.
                              
                              TRUE ~ FALSE)) %>%  #if else (if none of the previous conditions are met), set value to FALSE
  mutate(any_FitP = case_when(FitP == TRUE | Rep_FitP == TRUE ~ TRUE, # plant is any form of fitness plant
                              TRUE ~ FALSE))

#Note - added as.numeric() around the str_match calls above since an R update caused the previous version of this code to not work.

# str_match(x, pattern="string"), where x is a vector, and "string" is the character string to be extracted from each element of the vector x.  If the string isn't present, then NA will be returned.

# as.numeric(str_match(F_multi, as.character(Plant_ID))) will return, as a numeric variable, the values within the vector, F_multi,   

# To sum up:

# Fit_P is TRUE for rows representing the SELECTED Fitness plant

# Rep_FitP is TRUE for rows representing the SELECTED and the BACK-UP Fitness plant(s), IF AND ONLY IF there are replicates available. Rep_FitP is FALSE for the Main Fitness plant if there were no replicate fitness plants. Rep_FitP is TRUE for the Main Fitness plant and for the Replicate plants within the same segment.  For unmeasured plants (of any kind) Rep_FitP = FALSE.

# Any_FitP is TRUE for rows representing either the SELECTED fitness plant OR a BACK-UP Fitness plant.  


#View(AC_GermFlow_2)

#Tidy up
AC_GermFlow_3 <- AC_GermFlow_2 %>% 
  select(Block, Transect, Sequence, Donor, Recipient, Replicated, Plant_ID, FitP, Rep_FitP, any_FitP, everything()) %>% 
  arrange(Transect, Sequence, Recipient, Plant_ID)


#View(AC_GermFlow_3) # This data frame will be very useful for selecting Fitness plants and/or Fitness+Backup plants

```



**Fruit and Seed counts**  

Due to the structure of excel data sheets, it seems easiest to upload fruit and seed count data separately since different spreadsheets were used to record each. Info on plants' Block, Transect, sequence, etc. will be pulled from the fruit count sheets. As typos were discovered in fruit and seed counts, corrections were made in batches.

Updated by Devin Gamble: **Feb 05, 2023**  

```{r message = FALSE}
# Data on *when* fruits were collected will be omitted here; only the total fruit counts (closed, open, non-fitness) are retained from the csv

AC_fruitprod_1 <- read_csv(here::here("data_sheets", "fruit_seed_counts_final", "AC-fruit-production_2023-02-05.csv"), skip = 2) %>% 
  select(1:11) #omit sow and flower date, seed count, and date-specific fruit counts by column index

head(AC_fruitprod_1)
AC_fruitprod_2 <- AC_fruitprod_1 %>% 
  select(-c(Recipient, 9)) %>% # Exclude Recipient column that doesn't contain leading 0's in ID number
  rename(Recipient = `Recipient for Sorting`, Plant_ID = `Plant number of fitness plant (when chosen)`, closed_fruits_F = `Number of closed fruits used to estimate mean seeds per fruit (include multiple dates)`, open_fruits_F = `Open Fruits`, damaged_fruits_F = `Eaten or damaged fruits`, total_fruits_F = `Total number of all fruits produced by the plant (open + closed)`, nonfitness_fruits = `Total number of non-fitness fruits collected from segment`) 

# It's important to rename "Recipient for Sorting" to "Recipient" so that it can be used when merging AC_fruitprod_2 with AC_seedct_1)

#Note: total fruits do not include eaten/damaged fruit


# Seed count data (viable seeds)
# only seed count data are retained from this spreadsheet to minimize errors
AC_seedct_1 <- read_csv(here::here("data_sheets", "fruit_seed_counts_final", "AC-seed-count_2023-02-05.csv"), skip = 2) %>% 
  select(-c(3, 6, 7, 9:29)) %>% # No need to include columns in AC_fruitprod_1 that aren't needed for merging or that are extraneous (columns 9-29)
  rename(Recipient = `Recipient for Sorting`, Plant_ID = `Plant number of fitness plant (when chosen)`, seed_ct = `Total number of viable seeds counted across multiple dates`)

head(AC_seedct_1)

#merge data
AC_fruitseed_ct1 <- left_join(AC_fruitprod_2, AC_seedct_1, by = c("Sequence", "Transect", "Recipient", "Plant_ID")) # left_join ensures retaining all rows in AC_fruitprod_2, although the two dataframes merged here already contain the same number of observations (n=545).  Note that this number is higher than the number of "selected" fitness plants, so it must include fruit and seed counts of some replicates.

#View(AC_fruitseed_ct1)

# summary variables, tidying up
AC_fruitseed_ct2 <- AC_fruitseed_ct1 %>% 
  select(Transect, Sequence, Recipient, Plant_ID, closed_fruits_F, open_fruits_F, damaged_fruits_F, total_fruits_F, nonfitness_fruits, everything()) %>% 
  arrange(Transect, Sequence, Recipient)

## NOTE: total number of non-fitness fruits per segment may be under-represented here since not all counts were matched to fitness plants and therefore merged in.  Could exclude this column since it isn't being used in any analyses.  This column is a little bit confusing.  Each segment (Transect*Recipient combination) contains only one value, even if multiple replicate fitness plants are displayed.

```



**Seed Weights**  

*Note*: Prior to csv reading:
- header row for seed weights was moved down to line up with other headers

```{r}
# Read in only # seeds weighed and total weight
# Calculate mean weight per seed

# Note that, for year 2 (2023) field data, the Excel spread sheet already includes the mean individual seed mass, calculated across multiple dates, so this code doesn't need to be used.

AC_seedmass_1 <- read_csv(here::here("data_sheets", "seed_mass", "AC_Seed_Mass_2023-02-05.csv"), skip = 2)

head(AC_seedmass_1)
colnames(AC_seedmass_1) <- c("Sequence", "Transect", "Recipient_old", "Recipient", "Plant_ID", "closed_fruits_d1", "viable_seeds_d1", "seeds_weighed_d1", "seed_mass_mg_d1", "closed_fruits_d2", "viable_seeds_d2", "seeds_weighed_d2", "seed_mass_mg_d2", "closed_fruits_d3", "viable_seeds_d3", "seeds_weighed_d3", "seed_mass_mg_d3", "closed_fruits_d4", "viable_seeds_d4", "seeds_weighed_d4", "seed_mass_mg_d4", "closed_fruits_d5", "viable_seeds_d5", "seeds_weighed_d5", "seed_mass_mg_d5")

# Select only those variables needed to calculate mean individual seed mass for each fruit collection date and then to merge these with AC_fruitseed_ct2

AC_seedmass_2 <- AC_seedmass_1 %>% 
  select(-starts_with(c("closed_fruits_", "viable_seeds_")), -Recipient_old) %>% 
  mutate(msm_d1 = seed_mass_mg_d1/seeds_weighed_d1,
         msm_d2 = seed_mass_mg_d2/seeds_weighed_d2,
         msm_d3 = seed_mass_mg_d3/seeds_weighed_d3,
         msm_d4 = seed_mass_mg_d4/seeds_weighed_d4,
         msm_d5 = seed_mass_mg_d5/seeds_weighed_d5)
         
# AC_seedmass_2 has n=546 obs

AC_seedmass_3 <- AC_seedmass_2 %>%
  mutate(msm_all = rowMeans(select(AC_seedmass_2, starts_with("msm_")), na.rm = TRUE)) %>% 
  rowwise() %>% 
  mutate(sd_msm_all = sd(c_across(c(msm_d1:msm_d5)), na.rm = TRUE))
         
# AC_seedmass_2 also has n=546 obs.  Using na.rm = TRUE does not eliminate any rows

## Merge with fruit/seed count data frame

AC_fruitseed_ct3 <- merge(AC_fruitseed_ct2, AC_seedmass_3, by = c("Transect", "Sequence", "Recipient", "Plant_ID"), all.x = TRUE)
#all.x means that any fitness plant x ID combos that don't match up won't be included.

# Has n=545 observations, so one row not included in merge

```



Merge everything together:  

Note that AC_GermFlow_3 has 3546 observations (rows) because every plant sown as a seed is included

AC_fruitseed_ct3 has 545 observations because all selected and backup fitness plants are included

When no CLOSED FRUITS were counted, the number is scored as 0 (instead of NA) by the code in this chunk. This will include these fruits when calculating lifetime fecundity.

# Fitness Plants for which NO FRUITS were collected are scored as 0 by the code in this chunk

```{r}
AC_merged_df1 <- merge(AC_GermFlow_3, AC_fruitseed_ct3, by = c("Transect", "Sequence", "Recipient", "Plant_ID"), all.x = TRUE) %>% 
  select(Block, Transect, Sequence, Donor, Recipient, Replicated, Plant_ID, FitP, Rep_FitP, any_FitP, everything()) %>% 
  arrange(Block, Transect, Sequence, Recipient, Plant_ID) %>% 
  mutate(closed_fruits_F = as.numeric(closed_fruits_F),
         total_fruits_F = as.numeric(total_fruits_F)) #correct counts to numeric values

#View(AC_merged_df1)

#Correct Fruit NAs (but not seed count NAs) to 0s in cases where no fruit data were entered (fitness and non-fitness plants):
AC_merged_df2 <- AC_merged_df1 %>% 
  mutate(closed_fruits_F = replace_na(closed_fruits_F, 0),
         total_fruits_F = replace_na(total_fruits_F, 0),
         seed_ct = replace_na(seed_ct, 0)) #REPLACE ALL seed_ct NAs with 0 

# WARNING:  All non-fitness plants are now scored as 0 for closed_fruits, total_fruits, and seed_ct, even if they might have produced seeds. So, these plants must not be used for any fitness measures.  That should be fine because it's easy to filter these data only for selected and back-up fitness plants by using columns (FitP, Rep_FitP, and any_FitP)

#View(AC_merged_df2)
#Calculate mean seeds per fruit, total_est_seed prod
#variables renamed later
AC_merged_df3 <- AC_merged_df2 %>% 
  mutate(mean_seeds_per_fruit = seed_ct/closed_fruits_F,
         total_est_seed_production = mean_seeds_per_fruit*total_fruits_F) # equals lifetime fecundity
#More fitness variables calculated later

#View(AC_merged_df3)

# IMPORTANT:  mean_seeds_per_fruit and Total_est_seed_prod have NAs/NaNs for when there were no closed fruits (and therefore no seed count) (fitness plants only) because mean_seeds_per_fruit cannot be calculated in the absence of closed fruits.  mean_seeds_per_fruit is required for the estimate of Total_est_seed_prod.  So, when closed_F = 0, mean_seeds_per_fruit and Total_est_seed_prod cannot be calculated.

```



**Skeleton Weights & Corolla area and diameter**  

*grepl(pattern, x)* default is to ignore case

pattern = character string to be matched in a given character vector
x = character vector

grepl() will identify rows that DO contain the pattern
!grepl() will identify rows that DO NOT contain the pattern

filter(!grepl(pattern, x)) # will filter (retain) rows that do NOT contain the pattern

Load and merge-in these data sheets
```{r}
##
skel_weights_AC <- read_csv(here::here("data_sheets", "skeleton_and_stem_data", "skeleton_weights_AC_2023_03_01.csv")) %>% select(-Units, -7, -8) %>% 
  filter(!grepl("EXCLUDE", Notes)) %>% ## Filter out rows in which the Notes column does NOT contain the word "Exclude". Default for grepl is to ignore case.
  rename(Plant_ID = `Fitness Plant_ID`, AG_biomass_mg = `Skeleton Weights (mg)`)

# n = 441 rows before filtering out rows with "Exclude" in the Notes column
# n = 440 rows after filtering rows

sum(!is.na(skel_weights_AC$AG_biomass_mg))

# n = 331 plants with complete skeleton weights

#Watered points
skel_weights_AC_W <- read_csv(here::here("data_sheets", "skeleton_and_stem_data", "skeletons_watered_AC_2023_02_08.csv")) %>% 
  select(-`Units (mg)`) %>% 
  rename(Plant_ID = `Plant ID`, AG_biomass_mg = `Skeleton Weights`)

#Combine
skel_weights_all <- rbind(skel_weights_AC, skel_weights_AC_W) %>% 
  select(-Notes) %>% 
  filter(!is.na(AG_biomass_mg))

# n = 434 plants with complete skeleton weights, including watered transect

#Merge with full data set, which has 3546 observations

AC_merged_df4 <- merge(AC_merged_df3, skel_weights_all, by = c("Transect", "Recipient", "Plant_ID"), all.x = TRUE)

#includes Replicated Fitness plants... how many?
AC_NFskels <- AC_merged_df4 %>% 
  filter(!is.na(AG_biomass_mg)) %>% # Includes all rows skeleton data
  arrange(FitP) # Display so that the selected fitness plants are shown first
# 71/434 are Replicated Fitness plants, not main F plants

#View(AC_NFskels)
```


Corolla measurements

*grepl(pattern, x)* default is to ignore case

pattern = character string to be matched in a given character vector
x = character vector

grepl() will identify rows that DO contain the pattern
!grepl() will identify rows that DO NOT contain the pattern

filter(!grepl(pattern, x)) # will filter (retain) rows that do NOT contain the pattern


```{r warning = FALSE}
corollas_AC <- read_csv(here::here("data_sheets", "corolla_measures", "corollameasures_AC_2023-02-28.csv")) %>% select(1, 3, 4, 6, 7, 9, 11) %>% 
  rename(photo_date = 4, corolla_diam_mm = 5, corolla_area_mm2 = 6, notes_corolla = 7) %>% 
  filter(!grepl("REMOVE", notes_corolla)) ## Filter out rows in which the notes_corolla column does NOT contain the word "REMOVE" (not case-sensitive)
#Ignore warning; offending columns not selected

# corollas_AC has 3546 observations before removing rows with the word "REMOVE" in the notes column
# corollas_AC has 3541 observations after removing rows with the word "REMOVE" in the notes column

sum(!is.na(corollas_AC$photo_date)) # 597 rows have photo dates
sum(!is.na(corollas_AC$corolla_diam_mm)) # 588 rows have corolla diameters
sum(!is.na(corollas_AC$corolla_area_mm2)) # 565 rows have corolla_area_mm2

corollas_AC2 <- corollas_AC %>% 
  filter(!is.na(corolla_diam_mm)) %>% # keep rows that DO have corolla diameters
  mutate(photo_date = as_date(photo_date)) %>% #correct missing dates 
  mutate(Recipient_num = sprintf("%03d", (parse_number(Recipient)))) %>% # Fix Recipient names, retaining Recipient number with 3 digits, providing leading 0's if needed
  mutate(Recipient = as.character(str_c("AC_", Recipient_num))) %>% 
  select(-Recipient_num) %>% 
  arrange(Transect, Recipient, Plant_ID, photo_date) %>% # sort such that the first row for which there are duplicate Transect*Recipient*Plant_ID combinations is the one with the earliest photo_date
  distinct(Transect, Recipient, Plant_ID, .keep_all = TRUE) #Keep only the earliest photo date data for duplicates
#Only 6 duplicate observations (same plant, different dates) removed


## Merge with main data 
AC_merged_df5 <- merge(AC_merged_df4, corollas_AC2, by = c("Transect", "Recipient", "Plant_ID"), all.x = TRUE)
  

#check: includes NF (non-fitness) plants... 
AC_NFcorollas <- AC_merged_df5 %>% 
  filter(!is.na(corolla_diam_mm)) %>% 
  arrange(FitP)

#View(AC_NFcorollas)
#245/582 are Replicated Fitness & NF plants, not main F plants (157 totally NF plants = plants that are NA for FitP)

AC_NFcorollas <- AC_merged_df5 %>% 
  filter(!is.na(corolla_diam_mm)) %>% 
  arrange(Rep_FitP)

#View(AC_NFcorollas)
```




**Leaf Area & Weight**  

*grepl(pattern, x)* default is to ignore case

pattern = character string to be matched in a given character vector
x = character vector

grepl() will identify rows that DO contain the pattern
!grepl() will identify rows that DO NOT contain the pattern

filter(!grepl(pattern, x)) # will filter (retain) rows that do NOT contain the pattern


```{r}
leaves_AC <- read_csv(here::here("data_sheets", "leaf_data", "AC_SLA_data_20230522.csv")) %>% 
  rename(leaf_area_mm2 = 5, leafarea_notes = 6, leaf_dryweight_mg = 7, leafweight_notes = 8) %>% 
  filter(!grepl("EXCLUDE", leafarea_notes)) %>% ## Filter out rows in which the leafarea_notes column does NOT contain "EXCLUDE", not case-sensitive
  filter(!is.na(leaf_area_mm2)) %>% # Retain only rows that DO contain leaf area (or any value other than "NA").  One row contained the phrase "No Photo", so it was retained, but then coerced into NA when converted to numeric in next line (Transect 9, Plant_ID 3, AC_197)
  mutate(leaf_area_mm2 = as.numeric(leaf_area_mm2)) 
  
# NA coercion for "No photo" entered in area column.  Fine for this to be "NA" becuase no leaf area is available for it

#View(leaves_AC)
#Eliminate Duplicates
#Randomly select one leaf to be analyzed per transect x maternal ID combo
leaves_AC_duped <- leaves_AC %>% 
  mutate(duped1 = duplicated(select(leaves_AC, c(Block, Transect, Recipient))), #sort data frame by variables in vector, then assign logical variable, =TRUE to all but the first duplicated row for a given combination of Block, Transect, Recipient
         duped2 = duplicated(select(leaves_AC, c(Block, Transect, Recipient)), fromLast = TRUE), #logical variable, =TRUE for the FIRST  of two or more leaves sampled from the same Block, Transect, and Recipient
         duped = case_when(duped1|duped2 == TRUE ~ TRUE,  # When either duped1 or duped2 is TRUE, then duped = TRUE
                           TRUE ~ FALSE)) %>% # If neither duped1 or duped2 is a duplicate (is TRUE), then duped = FALSE 
  select(-c(duped1, duped2))

# Select dupe rows that have both area and weight!


#This seems to work the best!
leaves_AC_unique <- leaves_AC_duped %>% 
  group_by(Block, Transect, Recipient) %>% 
  slice_sample(n = 1) %>%  #select a random row for each combo of block, transect, recipient
  select(-c(duped, Plant_ID)) %>%  #Don't need plant ID...these were all non-fitness plants, and the slice_sample function removes duplicate leaves sampled from a given segment
  mutate(SLA_SEG = leaf_area_mm2 / leaf_dryweight_mg, # Calculate SPECIFIC LEAF AREA of the non-fitness plant sampled and selected at random (if there were duplicates) from each segment.
         LMA_SEG = 1 / SLA_SEG) %>% # Calculate LEAF MASS PER AREA of the non-fitness plant sampled and selected at random from each segment, Following line added: SEG indicates a segment-wide estimate
  rename(leaf_area_mm2_SEG = leaf_area_mm2,
         leaf_dryweight_mg_SEG = leaf_dryweight_mg)

# n=289 

sum(!is.na(leaves_AC_unique$leaf_area_mm2_SEG)) # n=288 rows with leaf area for a given segment
sum(!is.na(leaves_AC_unique$leaf_dryweight_mg_SEG)) # n=289 rows with leaf dry weight for a given segment


#Merge in to main data 
AC_merged_df6 <- merge(AC_merged_df5, leaves_AC_unique, by = c("Block", "Transect", "Recipient"), all.x = TRUE) #replicates leaf area & weight for every plant of a transect recipient combo


#
##Include plant-level leaf measurements as well:
leaves_AC_ind <- leaves_AC %>% 
  mutate(Plant_ID = case_when(Plant_ID == "No ID" ~ NA,
                              TRUE ~ Plant_ID)) %>%  #Fix missing ID names; convert "No ID" to "NA", else retain as Plant_ID
  filter(!is.na(Plant_ID)) %>% #remove obs missing ID (2), retain all rows with Plant_ID indicated
  select(Block, Transect, Recipient, Plant_ID, leaf_area_mm2, leaf_dryweight_mg) %>% #ignore notes
  mutate(SLA = leaf_area_mm2 / leaf_dryweight_mg,
         LMA = 1 / SLA)

sum(!is.na(leaves_AC_ind$Plant_ID)) # n=326, before converting "No ID" to NA; n=324 AFTER converting "No ID" to NA

#Merge - sheet 6b
AC_merged_df6b <- merge(AC_merged_df6, leaves_AC_ind, by = c("Block", "Transect", "Recipient", "Plant_ID"), all.x = TRUE) #measures of individual plants. Total # obs unchanged, but these 324 leaves will now be associated with NON-fitness Plant_IDs, not just segments.

# make sure all measurements merged in
AC_NFleaves <- AC_merged_df6b %>% 
  filter(!is.na(leaf_dryweight_mg)) %>% 
  arrange(FitP)

# Should be all/mostly NF -- 
# IMPORTANT:  Rows 294-299 (n=5) are FITNESS PLANTS -- not sure why leaves were collected from them.

#View(AC_NFleaves)

```



Error checks:

```{r eval = FALSE}
##Check for mismatched (fitness) plants

AC_Echeck1 <- AC_merged_df6b %>% 
  filter(any_FitP == FALSE & total_fruits_F != 0) #do the same for seed count, using `>` and `!=`

AC_Echeck2 <- AC_merged_df6b %>% 
  filter(any_FitP == TRUE) %>% 
  filter(closed_fruits_F == 0 & seed_ct > 0)

##NA/NaN/Info values for mean seeds per fruit/est seed prod
AC_Echeck3 <- AC_merged_df6b %>% 
  filter(any_FitP == TRUE & is.na(as.numeric(mean_seeds_per_fruit))) # Do any fitness plants have NA for mean_seeds_per_fruit?

AC_Echeck4 <- AC_merged_df6b %>% 
  filter(any_FitP == TRUE & !is.finite(mean_seeds_per_fruit))

# YES -- 49 plants have NaN values for mean_seeds_per_fruit and est_seed_prod because they have NO CLOSED FRUITS

## Check for NA seed counts for fitness plants (when fruit production > 0)
# Will be empty when seed_ct NAs are replaced with 0
AC_Echeck5 <- AC_merged_df6b %>% 
  filter(any_FitP == TRUE & is.na(seed_ct))
##NAs present here before setting seed_ct NAs to 0 were from fitness plants that had 0 closed fruit.  Now, all seed_counts are 0 instead of NA, but if 0 closed fruit, then mean_seeds_per_fruit and est_seed_prod will be NaN.


#View(AC_Echeck5)
#Seed mass
AC_Echeck6 <- AC_merged_df6b %>% 
  filter(any_FitP == FALSE & !is.na(msm_all)) # Do any plants that are NOT fitness plants have a mean_seed_mass value?  No.

```

<br>  


## Trait calculations 


#### Phenology  

do.call constructs and executes a function call from a name or a function and a list of arguments to be passed to it.

*Usage*

do.call(what, args, quote = FALSE, envir = parent.frame())

*Arguments*
what: either a function or a non-empty character string naming the function to be called.  In the code chunk below, the "what" is the function, pmin.

args: a list of arguments to the function call. The names attribute of args gives the argument names.  In the code chunk below, the "argument" is the list of vectors (the columns beginning with "Fl_") across which the minimum value will be selected and assigned to the new variable called FFD.

Use na.rm=TRUE to ignore any values in the list of vectors that are NA.

```{r}
AC_merged_df_fl <- AC_merged_df6b %>% 
  mutate(FFD = do.call(pmin, c(select(., starts_with('Fl_')), na.rm = TRUE)), #First flowering date.  For each row, selects the minimum value of all of the columns that begin with "Fl_", removing any values that are "NA".  FFD is a Date variable, like the members of the list.
         days_germ2flower = as.numeric(FFD - Germ_Date), #days from germination to flowering
         days_sow2flower = as.numeric(FFD - Sow_Date), #days from lab sowing to flowering
         days_plant2flower = as.numeric(FFD - Plant_Date), #days from field planting to flowering
         LFD = do.call(pmax, c(select(., starts_with('Fl_')), na.rm = TRUE)), #last flowering date
         fl_duration = as.numeric(LFD - FFD)) #Flowering duration

#View(AC_merged_df_fl) # n=3546 obs. with 73 variables

```


**Revise Calculations of Fitness Data to match Year 2**


```{r}

#Updating Fruit count columns
#All Fitness plants (any kind) should have non-NA values for fruit and seed counts

# If any Fitness plant (a plant for which any_FitP == TRUE) has a NA value for closed_fruits_F, open_fruits_F, or total_fruits_F the "NA" should be changed to 0

# If any Fitness plant has a value for closed_fruits_F, open_fruits_F, or total_fruits_F that is >= 0, this value should be retained

AC_merged_df_flB <- AC_merged_df_fl %>% 
  mutate(closed_fruits_F = case_when(any_FitP == TRUE & is.na(closed_fruits_F) ~ 0,
                                     any_FitP == TRUE & !is.na(closed_fruits_F) ~ closed_fruits_F,
                                     TRUE ~ closed_fruits_F), # If neither of the above 2 conditions are true, then retain value of closed_fruits_F
         open_fruits_F = case_when(any_FitP == TRUE & is.na(open_fruits_F) ~ 0,
                                   any_FitP == TRUE & !is.na(open_fruits_F) ~ open_fruits_F,
                                   TRUE ~ open_fruits_F), # If neither of the above 2 conditions are true, then retain value of open_fruits_F
         total_fruits_F = case_when(any_FitP == TRUE & is.na(total_fruits_F) ~ 0,
                                   any_FitP == TRUE & !is.na(total_fruits_F) ~ total_fruits_F,
                                   TRUE ~ total_fruits_F))# If neither of the above 2 conditions are true, then retain total_fruits_F


#Survival, Fruit Production, and Seed Production success (0 or 1)


AC_merged_df_flC <- AC_merged_df_flB %>% 
  mutate(surv_to_germ = case_when(!is.na(Germ_Date) ~ 1, #plants that germinated have a Germ_Date, so their survivorship = 1
                                  is.na(Germ_Date) ~ 0), #plants that did not germinate have an "NA" for Germ_Date; survivorship = 0
         surv_to_flower = case_when(!is.na(FFD) ~ 1, # plants that survived to flower
                                  is.na(FFD) ~ 0), # plants that did not flower
         surv_to_fruitprod = case_when(any_FitP == TRUE & total_fruits_F > 0 ~ 1, #plants that survived to produce fruit
                                       any_FitP == TRUE & total_fruits_F == 0 ~ 0),
         prod_closed_fruits = case_when(any_FitP == TRUE & closed_fruits_F > 0 ~ 1, #probability that plant produced closed fruits (0 or 1)
                                        any_FitP == TRUE & closed_fruits_F == 0 ~ 0),
         prod_filled_seeds = case_when(any_FitP == TRUE & seed_ct > 0 ~ 1, #plants that survived to produce fruit with viable seeds (0 or 1)
                                       any_FitP == TRUE & seed_ct == 0 ~ 0))  #else = 0 
  
#View(AC_merged_df_flC)

#Calculate Fecundity success (0 or 1)

AC_merged_df_fl2 <- AC_merged_df_flC %>% 
  rename(est_fecundity = total_est_seed_production) %>% #rename to match Y2
  mutate(across(c(est_fecundity, mean_seeds_per_fruit), ~ as.numeric(na_if(., NaN)))) %>% #Converts to NA if any of the values are "NaN"
  mutate(mean_seeds_per_fruit = case_when(any_FitP == TRUE & closed_fruits_F == 0 ~ NA, # NA when 0 closed fruits
                                          TRUE ~ mean_seeds_per_fruit)) %>%  #else, original value
  mutate(est_fecundity = case_when(any_FitP == TRUE & closed_fruits_F == 0 & open_fruits_F == 0 ~ 0,
                                               any_FitP == TRUE & closed_fruits_F == 0 & open_fruits_F >= 1 ~ NA,
                                               any_FitP == TRUE & !is.na(est_fecundity) ~  est_fecundity))

```


### d13C data  


grep, grepl, regexpr, gregexpr, regexec and gregexec search for matches to argument pattern within each element of a character vector: they differ in the format of and amount of detail in the results.

sub and gsub perform replacement of the first and all matches respectively.  Here, we will use gsub

*gsub(pattern, replacement, x)* Default is to ignore case

pattern is the character string to be matched in a given character vector
replacement is the string to be used to replace the "pattern"
x is the character vector in which matches are sought

*substr(x, start, stop)*
x is a character vector (sample_ID in the code below)
start is the first element in a cell to be extracted or replaced
stop is the last element in a cell to be extracted or replaced

*grepl(pattern, x)* default is to ignore case

pattern = character string to be matched in a given character vector
x = character vector

grepl() will identify rows that DO contain the pattern
!grepl() will identify rows that DO NOT contain the pattern

filter(!grepl(pattern, x)) # will filter (retain) rows that do NOT contain the pattern

*str_remove(string, pattern) -- REMOVE matched pattern*

string = a character vector, or something that can be coerced into one

pattern = a regular expression. If this is "^0+", str_remove will REMOVE LEADING ZEROS

str_remove will look at each element in the character vector and remove the first character(s) in the element that match the pattern


```{r message = FALSE}
Nemo_d13C <- read_csv(here::here("data_sheets", "isotope_data", "d13C_2022.csv")) %>% 
  select(1,2,3,5,6,9) %>% 
  rename(sample_ID = 1, d13C = 2, totalC_ug = 3, sample_weight_mg = 6)
#Save as UTF-8 file from excel to avoid import error

#filter to AC samples
Nemo_d13C_AC <- Nemo_d13C %>% 
  filter(grepl('AC', sample_ID))

#unravel sample ID
Nemo_d13_AC2 <- Nemo_d13C_AC %>% 
  mutate(Recipient = gsub('-', '_', substr(sample_ID, 1, 6)), 
         Transect = as.numeric(str_remove(substr(sample_ID, 8, 10), "^0+")),
         Plant_ID = as.numeric(substr(sample_ID, 12,13))) %>% 
  select(Transect, Recipient, Plant_ID, d13C, sample_weight_mg) #un-un-select Plant_ID


#Merge
AC_merged_df_fl3 <- merge(AC_merged_df_fl2, Nemo_d13_AC2, by = c("Recipient", "Transect", "Plant_ID"), all.x = TRUE) #add Pland ID to merge by


#check that all data made it (266 obs)
#testdf <- AC_merged_df_fl3 %>% 
#  filter(!is.na(d13C))

#Check d13C for F/NF plants... 
AC_NFd13C <- AC_merged_df_fl3 %>% 
  filter(!is.na(d13C)) %>% 
  arrange(FitP)
#includes 10 Rep Fs; rest main F


#Create segment-wide estimate of d13C:
Nemo_d13_AC2b <- Nemo_d13_AC2 %>% 
  rename(d13C_SEG = d13C) %>% #rename for seg-wide measure
  select(Transect, Recipient, d13C_SEG) #un-select Plant_ID, dryweight of sample


AC_merged_df_fl3b <- merge(AC_merged_df_fl3, Nemo_d13_AC2b, by = c("Recipient", "Transect"), all.x = TRUE) 
#Merge by Recipient and Transect only: segment-wide estimates of d13C since some plants were NF

```


```{r message = FALSE}
Nemo_d13C <- read_csv(here::here("data_sheets", "isotope_data", "d13C_2022.csv")) %>% 
  select(1,2,3,5,6,9) %>% 
  rename(sample_ID = 1, d13C = 2, totalC_ug = 3, sample_weight_mg = 6)
#Save as UTF-8 file from excel to avoid import error

names(Nemo_d13C)
#filter to AC samples
Nemo_d13C_AC <- Nemo_d13C %>% 
  filter(grepl('AC', sample_ID)) # Identify and extract the rows in which the character string "AC" appears in the sample_ID row (n=266)

class(Nemo_d13C$sample_ID) # character vector
#unravel sample ID
Nemo_d13_AC2 <- Nemo_d13C_AC %>%
  mutate(Recipient = gsub('-', '_', substr(sample_ID, 1, 6)), # gsub function will replace hyphens(-) with underscores(_) in a character vector.  In this case, the character vector is sample_ID.  The replacement is for any portion of the substring (the content of the character string) between digits 1 and 6.
         Transect = as.numeric(str_remove(substr(sample_ID, 8, 10), "^0+")), # Creates Transect variable by first using substr() to find the 8th-10th digits of the sample_ID column, and then removing the leading 0s using str_remove() and "^0+"
         Plant_ID = as.numeric(substr(sample_ID, 12,13))) %>% # Creates Plant_ID variable that contains the 12th-13th digits of the sample_ID column.  The as.numeric() function removes leading 0s when present.
  select(Transect, Recipient, Plant_ID, d13C, sample_weight_mg) #un-un-select Plant_ID


#Merge
AC_merged_df7 <- merge(AC_merged_df6b, Nemo_d13_AC2, by = c("Recipient", "Transect", "Plant_ID"), all.x = TRUE) #add Plant_ID to merge by


#check that all data made it (266 obs)
#testdf <- AC_merged_df_fl3 %>% 
#  filter(!is.na(d13C))

#Check d13C for F/NF plants... 
AC_NFd13C <- AC_merged_df7 %>% 
  filter(!is.na(d13C)) %>%  # Extract only those fitness plants with isotope data
  arrange(FitP) # Sort by FitP (TRUE/FALSE)
#includes 10 Replicate Fitness plants (n=10); the remaining are the selected fitenss plants (n=256)


#Create segment-wide estimate of d13C:
Nemo_d13_AC2b <- Nemo_d13_AC2 %>% 
  rename(d13C_SEG = d13C) %>% #rename for seg-wide measure
  select(Transect, Recipient, d13C_SEG) #un-select Plant_ID, dryweight of sample


AC_merged_df_fl3 <- merge(AC_merged_df_fl2, Nemo_d13_AC2b, by = c("Recipient", "Transect"), all.x = TRUE) 
# Merge by Recipient and Transect only: This will include data from the 10 non-fitness plants, assigning their isotope values to the entire segment (to all Plant_IDs in the segment).

sum(!is.na(AC_merged_df_fl3b$d13C_SEG)) # 2660 rows have d13C values because each segment is represented by the same d13C value for each Plant_ID

sum(!is.na(AC_merged_df_fl3$d13C)) # 266 rows have d13C values, because each segment is represented by the one Plant_ID (Fitness or Non-fitness) for which the d13C values is available


```


##### Segment-wide estimates for skeleton weight, corolla area & diameter  

**Skeleton Weight**  

*subset(x, select)*

subset() returns subsets of vectors, matrices, or data frames that meet conditions

x = object to be subsetted (in the code below, it's the dataframe, skel_weights_seg1, which has 433 observations)

select = columns to select from the data frame

```{r}
#Merge to identify MAIN fitness plants. Merge skeleton weights with long-form data set containing germination, flowering data, and fitness plant categories (FitP, Rep_FitP, and any_FitP)

sum(!is.na(skel_weights_all$AG_biomass_mg)) # n=434

skel_weights_seg1 <- merge(AC_GermFlow_3, skel_weights_all, by = c("Recipient", "Transect", "Plant_ID"), all.x = TRUE) %>% 
  filter(!is.na(AG_biomass_mg)) %>%  # Retain rows for which AboveGround biomass is PRESENT
  select(Block, Transect, Sequence, Donor, Recipient, Replicated, Plant_ID, FitP, Rep_FitP, any_FitP, AG_biomass_mg)

sum(!is.na(skel_weights_seg1$AG_biomass_mg)) # n=433 (One watered plant is missing relative to skel_weights_all; Transect W2, Recipient AC_085, Plant 4

# Count number of rows with each TRUE/FALSE/NA combination of logical vectors.

skel_weights_seg1 %>% count(FitP, Rep_FitP)

skel_weights_seg1 %>% count(FitP, Rep_FitP, any_FitP)

# Test comparison

skel_weights_test_comp <- anti_join(skel_weights_all, skel_weights_seg1, by = c("Transect", "Recipient"))


#Highlight ALL DUPES (multiple measures within a segment)

skel_weights_duped <- skel_weights_seg1 %>% 
  mutate(duped1 = duplicated(subset(skel_weights_seg1, select = c("Block", "Transect", "Sequence", "Donor", "Recipient"))), # Assigns TRUE to all but the FIRST of two or more skeletons weighed from the same segment (with the same combination of Block, Transect, Sequence, and Donor)
         duped2 = duplicated(subset(skel_weights_seg1, select = c("Block", "Transect", "Sequence", "Donor", "Recipient")), fromLast = TRUE), # Assigns TRUE to ALL but the LAST of two or more skeletons weighed from the same segment (with the same combination of Block, Transect, Sequence, and Donor)
         duped = case_when(duped1|duped2 == TRUE ~ TRUE, # When either duped1 or duped2 is TRUE, then duped = TRUE
                           TRUE ~ FALSE)) # If neither duped1 or duped2 is a duplicate (is TRUE), then duped = FALSE
    
# n = 433 observations

skel_weights_duped %>% count(FitP, Rep_FitP, any_FitP)


#Filter out Replicated Plants when a Main plant is available (non-watered transects only)

#Note: Non-main FitPs (replicated) retained when only when a single measure taken from a segment, but duplicates (2+) of replicated plants are removed

# skel_weights_duped has 433 observations.  Now, let's remove unnecessary replicates, but keep the necessary replicates (where there is a skeleton weight for a segment even if it isn't from the original selected FITNESS plant)

skel_weights_unduped1 <- skel_weights_duped %>% 
  filter(case_when(duped == TRUE & Replicated == "R" & Block != "W" ~ FitP == TRUE, # If a row is duplicated, represents a segment with replicates, AND is in an UNwatered block, then the statement FitP == TRUE is evaluated as either TRUE or FALSE, which would be the output value.  If FitP = TRUE, filtering will RETAIN these rows.  These will represent the originally assiged Fitness plant when replicates (Non-fitness plants) are available for the segment
                   
                   TRUE ~ any_FitP == TRUE)) # %>% #If the previous condition is FALSE (meaning that EITHER there are no duplicates OR no replicates, or the Block is Watered), then any_FitP == TRUE will be evaluated.  If any_FitP is TRUE in this group, then filtering will retain the row
  # filter(Block != "W")

skel_weights_unduped1 %>% count(FitP, Rep_FitP, any_FitP)

# In sum:  the filter() function will keep only the rows in which either:
  # 1) duped is TRUE, Replicated is "R", Block is not "W", AND FitP = TRUE, or
  # 2) any_FitP = TRUE

# skel_weights_unduped1 has 268 observations (excluding Watered transects), including 8 non-main (replicated) fitness plants (FitP = FALSE for these plants)


#Randomly selected F plants - one measure per available segment, including watered plots

skel_weights_seg_RAND <- skel_weights_duped %>% 
  group_by(Block, Transect, Recipient) %>% 
  slice_sample(n = 1) %>%  #select ONE random row for each combo of block, transect, recipient
  select(-c(duped, Plant_ID)) %>%
  ungroup()#  %>% # Need to include ungroup() in order for count function (see belw) to work.
  #filter(Block != "W") 
 # select(Block:Recipient) #temp filter
#Confirms # obs = # segments (n = 310) --- confirmed

# skel_weights_seg_RAND has 269 observations (w/o W)
# skel_weights_seg_RAND has 310 observations (w/W)

skel_weights_seg_RAND %>% count(FitP, Rep_FitP, any_FitP) # COUNT function not working


# Anti-join to see missing observations.  This anti-join function compares two dataframes and returns all of the rows in x (the first data frame) that are not present in y (the second date frame). Here, there is 1 plant in skel_weights_seg_RAND (n=269) that is NOT in skel_weights_unduped1 (n=268)

skel_weights_unduped_comp <- anti_join(skel_weights_seg_RAND, skel_weights_unduped1, by = c("Block", "Transect", "Sequence", "Donor", "Recipient")) %>% 
  select(-c(Replicated:any_FitP, duped1, duped2))

# QUESTION: why isn't this plant in skel_weights_unduped1? (Block 3, Transect 9, Sequence 311, Recipient AC_218). 

# Main plant measures - remove unnecessary columns, contains 8 non-fitness plants (n=268)
skel_weights_unduped1b <- skel_weights_unduped1 %>% 
  select(-c(Replicated:any_FitP, duped, duped1, duped2)) 

#Make sure columns match up for skel_weights_uduped1b and skel_weights_unduped_comp

#Combine with missing complement - measurements from replicated/NF plants where no main plant available
skel_weights_SEG <- rbind(skel_weights_unduped1b, skel_weights_unduped_comp) %>% 
  rename(AG_biomass_mg_SEG = AG_biomass_mg)
#End result: One measure per segment (from which a skeleton was collected), with main fitness plants retained where available and NF/Replicated FitPs selected "at random" (using slice_sample(n=1)), n = 269, not including Watered transects.

# Merge with main data sheet
AC_merged_df_fl4 <- merge(AC_merged_df_fl3b, skel_weights_SEG, by = c("Block", "Transect", "Sequence", "Donor", "Recipient"), all.x = TRUE)

```



**Corolla Diameter & Area**  
Use same approach as above

```{r}
#Merge to identify MAIN fitness plants

# First, extract rows with corolla diameters from the long data set that includes all traits (AC_merged_df5)

corollas_seg1 <- AC_merged_df5 %>% 
  filter(!is.na(corolla_diam_mm)) %>% #diameter prioritized - main trait to measure (& fewer NAs)
  select(Block, Transect, Sequence, Donor, Recipient, Replicated, Plant_ID, FitP, Rep_FitP, any_FitP, corolla_diam_mm, corolla_area_mm2) 

sum(!is.na(corollas_seg1$corolla_diam_mm)) # n=582 corolla diameters measured, including Fitness and non-fitness plants

#Highlight duplicates
corollas_duped <- corollas_seg1 %>% 
  mutate(duped1 = duplicated(subset(corollas_seg1, select = c("Block", "Transect", "Sequence", "Donor", "Recipient"))), # Assigns TRUE to all but the FIRST of two or more corollas measured from the same segment (with the same combination of Block, Transect, Sequence, and Donor)
         duped2 = duplicated(subset(corollas_seg1, select = c("Block", "Transect", "Sequence", "Donor", "Recipient")), fromLast = TRUE),# Assigns TRUE to ALL but the LAST of two or more corollas measured from the same segment (with the same combination of Block, Transect, Sequence, and Donor)
         duped = case_when(duped1|duped2 == TRUE ~ TRUE,# When either duped1 or duped2 is TRUE, then duped = TRUE
                           TRUE ~ FALSE)) # %>%
  # If neither duped1 or duped2 is a duplicate (is TRUE), then duped = FALSE
  #filter(Block != "W") 


sum(!is.na(corollas_duped$corolla_diam_mm)) # n=582, including Fitness and non-fitness plants

corollas_duped %>% count(FitP, Rep_FitP, any_FitP)

corollas_duped %>% count(Transect, na.rm=TRUE)


# Filter out Replicated Plants when a Main Fitness plant is available (non-watered transects only)

#Note: Non-main FitPs retained when only when a single measure taken from a segment, but duplicates (2+) of replicated plants are removed


#Note: Duplicates (2+) of replicated plants are removed; merged back in after random selection below

# corollas_duped has 582 observations.  Now, let's remove unnecessary replicates, but keep necessary replicates (i.e., where there is a corolla diameter for a segment even if it isn't from the original selected FITNESS plant)


corollas_unduped1 <- corollas_duped %>% 
  filter(case_when(duped == TRUE & Replicated == "R" & Block != "W" ~ FitP == TRUE, # If a row is duplicated, AND represents a segment with replicates, AND is in an UNwatered block, then the statement FitP == TRUE is evaluated as either TRUE or FALSE, which would be the output value.  If FitP = TRUE, filtering will RETAIN these rows.  These will represent the originally assigned Fitness plant when replicates (Non-fitness plants) are available for the segment.
                   TRUE ~ any_FitP == TRUE))  # %>%  #If the previous condition is FALSE (meaning that EITHER there are no duplicates OR no replicates, or the Block is Watered), then any_FitP == TRUE will be evaluated.  If any_FitP is TRUE in this group, then filtering will retain the row.
  # filter(Block != "W") 

corollas_unduped1 %>% count(FitP, Rep_FitP, any_FitP)

# corollas_unduped1 has 90 rows including Watered transects
# corollas_unduped1 has 241 rows excluding Watered transects.  Only 7 of these are not FitP plants (FitP = FALSE)

# In sum:  the filter() function will keep only the rows in which either:
  # 1) duped is TRUE, Replicated is "R", Block is not "W", AND FitP = TRUE, or
  # 2) any_FitP = TRUE (but either no duplications or no replicated values in segment)

sum(!is.na(corollas_unduped1$corolla_diam_mm))


# Randomly selected F plants - one measure per available segment, including watered transects

corollas_seg_RAND <- corollas_duped %>% 
  group_by(Block, Transect, Recipient) %>% 
  slice_sample(n = 1) %>%  #select a random row for each  combo of block, transect, recipient
  select(-c(duped, Plant_ID)) %>%
  ungroup() # %>% # Need to include ungroup() in order for count function (see below) to work
  # filter(Block != "W")

## corollas_seg_RAND has 309 total obs (including W block); 267 obs excluding W block - shouldn't this be n = 269?

corollas_seg_RAND %>% count(FitP, Rep_FitP, any_FitP) 
  
  
# Anti-join to see missing observations.  This anti-join function compares two dataframes and returns all of the rows in x (the first data frame) that are not present in y (the second date frame). Here, there is XX plant in corollas_seg_RAND (n=XXX) that are NOT in corollas_unduped1 (n=XXX)


corollas_unduped_comp <- anti_join(corollas_seg_RAND, corollas_unduped1, by = c("Block", "Transect", "Sequence", "Donor", "Recipient")) %>% 
  select(-c(Replicated:any_FitP, duped1, duped2))

corollas_unduped_comp %>% count(FitP, Rep_FitP, any_FitP)

# corollas_unduped_comp %>% count(FitP, Rep_FitP, any_FitP) Can only run this line of code if corollas_unduped_comp includes FitP, Rep_FitP, and any_FitP columns.

# corollas_unduped_comp has 26 observations; these are present in corollas_seg_RAND (n=309) but not in corollas_unduped1 (n=331), but note that this number could change with the content of corollas_RAND if _RAND changes due to random nature of slice().  20 of these are neither Main Fitness plants NOR Any_FitP (replicate fitness plants).  2 of them are not Main Fitness plants, but ARE replicate fitness plants (Any_FitP). 2 are in Watered plots.

# corollas_unduped1 does contains 7 non-fitness plants (replicates)
# corollas_seg_RAND contains 110 non-fitness plants


#Main plant measures - remove unnecessary columns
corollas_unduped1b <- corollas_unduped1 %>% 
  select(-c(Replicated:any_FitP, duped, duped1, duped2)) 

# Make sure columns match up for corollas_unduped1b and corollas_unduped_comp

# n = 241 observations
# n = 26 observations

#Combine with missing complement - measurements from replicated/NF plants where no main plant available

corollas_SEG <- rbind(corollas_unduped1b, corollas_unduped_comp) %>% 
  rename(corolla_diam_mm_SEG = corolla_diam_mm,
         corolla_area_mm2_SEG = corolla_area_mm2) #rename vars

#End result: One measure per segment (from which a skeleton was collected), with main fitness plants retained where available and NF/Replicated FitPs selected "at random" (using slice_sample(n=1))

#double-check that obs total as expected

# corollas_SEG = 267 observations, which is sum of 241 + 26

#Merge with main data set
AC_merged_df_fl5 <- merge(AC_merged_df_fl4, corollas_SEG, by = c("Block", "Transect", "Sequence", "Donor", "Recipient"), all.x = TRUE)

```



**Duplicate & Final Error Check**  

```{r}
#All rows
AC_merged_df_fl5 %>% 
  select(Block:Plant_ID) %>% 
  get_dupes()


#Fitness Plants
AC_merged_df_fl5 %>% 
  filter(any_FitP == TRUE) %>% 
  get_dupes()


#Main fitness plants
AC_merged_df_fl5 %>% 
  filter(FitP == TRUE) %>% 
  get_dupes()

```



## Master sheets (v1)  


```{r message = FALSE}
## First, create a Full (long) version with all data - one row per plant 

AC_mastersheet_v1 <- AC_merged_df_fl5 %>% 
  mutate(Year = 2022, Gen = "G1") %>% #label year and generation
  select(Year, Gen, Block, Transect, Sequence, Donor, Recipient, Replicated, Plant_ID, FitP, Rep_FitP, any_FitP, F_plant, F_multi, F_plant_notes, everything()) %>% 
  arrange(Block, Transect, Sequence, Recipient, Plant_ID)

#Rename and organize variables to match Year 2 data:
AC_mastersheet_v2 <- AC_mastersheet_v1 %>% 
  rename(F_plant_ID = F_plant, #number of F plant
         F_plant = FitP, #T/F is F plant
         filled_seeds = seed_ct,
         open_fruits = open_fruits_F,
         closed_fruits = closed_fruits_F,
         total_fruits = total_fruits_F,
         skel_dryweight_mg = AG_biomass_mg,
         skel_dryweight_mg_SEG = AG_biomass_mg_SEG) %>% 
  mutate(est_fecundity_int = round(est_fecundity)) #round to nearest whole number


 #Add Greenhouse cohort
#2021 Tray position data sheets - extract and merge in greenhouse cohort data:
AC_tray21 <- read_csv(here::here("data_sheets", "tray_positions_2021_year1", "AC_tray_rand.csv"), skip = 1) %>% 
  select(Cohort, Donor_ID, Recipient_ID) %>% #Block and Transect not necessary to save here
  mutate(Recipient_num = sprintf("%03d", (parse_number(Recipient_ID)))) %>% #Fix Recipient/Donor names
  mutate(Recipient = as.character(str_c("AC_", Recipient_num))) %>% 
  mutate(Donor_num = sprintf("%03d", (parse_number(Donor_ID)))) %>% 
  mutate(Donor = as.character(str_c("AC_", Donor_num))) %>%
  select(-c(Donor_num, Recipient_num, Donor_ID, Recipient_ID)) %>% 
  distinct() #remove duplicate cases


#merge
AC_mastersheet_v3 <- left_join(AC_mastersheet_v2, AC_tray21, by = c("Donor", "Recipient")) %>% 
  select(-c(F_plant_notes, Fl_4.9:flr_P, damaged_fruits_F, seeds_weighed_d1:msm_d5, photo_date, notes_corolla, leafarea_notes, leafweight_notes)) %>% #Remove unnecessary columns 
  select(Year, Sequence, Cohort, Block, Transect, Donor, Recipient, Gen, Replicated, Plant_ID, F_plant:Plant_Date, FFD, LFD, fl_duration, days_germ2flower:days_plant2flower, corolla_diam_mm, corolla_diam_mm_SEG, corolla_area_mm2, corolla_area_mm2_SEG, leaf_area_mm2:LMA, leaf_area_mm2_SEG:LMA_SEG, skel_dryweight_mg, skel_dryweight_mg_SEG, d13C, d13C_SEG, sample_weight_mg, closed_fruits:est_fecundity, est_fecundity_int, everything()) #Reorder columns

```



**Write CSVs**  

```{r}

#Save full (long) version
write_csv(AC_mastersheet_v3, here::here("data_sheets", "compiled_sheets", "AC_mastersheet_full_2022.csv"))
# has records of all plants (including non-fitness)


#
## Fitness Plants Only

AC_mastersheet_F_mains <-  AC_mastersheet_v3 %>% 
  filter(F_plant == TRUE) #Only main fitness plants

AC_mastersheet_F_all <- AC_mastersheet_v3 %>% 
  filter(any_FitP == TRUE) #main and multiple fitness plants (IDs replicated in watering experiment)


write_csv(AC_mastersheet_F_mains, here::here("data_sheets", "compiled_sheets", "AC_mastersheet_Fitness-mains_2022.csv"))

write_csv(AC_mastersheet_F_all, here::here("data_sheets", "compiled_sheets", "AC_mastersheet_Fitness-all_2022.csv"))
```



